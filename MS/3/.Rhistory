rows_count <- nrow(interval_data)
sum <- 0
for (row in c(1: rows_count)) {
middle_value <- as.numeric((interval_data[row, 1] + interval_data[row, 2]) / 2)
sum <- sum + middle_value * as.numeric(interval_data[row, 3])
}
mean <- sum / length(data_vector)
return(mean)
}
# Знаходження дисперсії
get_dispersion <- function(data_vector, delimiter = 1) {
if (delimiter < 1 | delimiter > length(data_vector) | length(data_vector) == 0)
return(NULL)
data_vector <- sort(data_vector)
interval_data <- as_interval_variation(data_vector, delimiter)
rows_count <- nrow(interval_data)
dispersion <- 0
mean <- get_mean(data_vector, delimiter)
for (row in c(1: rows_count)) {
middle_value <- as.numeric((interval_data[row, 1] + interval_data[row, 2]) / 2)
dispersion <- dispersion + ((middle_value - mean) ^ 2) * as.numeric(interval_data[row, 3])
}
dispersion <- dispersion / length(data_vector)
return(dispersion)
}
# Знаходження точності обчислень як середньоквадратичного відхилення(метод моментів)
get_standard_deviation <- function(data_vector, delimiter = 1) {
data_vector <- sort(data_vector)
return (sqrt(get_dispersion(data_vector, delimiter)))
}
# Знаходження точності обчислень методом найбільшої подібності
get_deviation_max_likelihood <- function(data_vector, delimiter = 1) {
if (delimiter < 1 | delimiter > length(data_vector) | length(data_vector) == 0)
return(NULL)
data_vector <- sort(data_vector)
interval_data <- as_interval_variation(data_vector, delimiter)
rows_count <- nrow(interval_data)
dispersion <- 0
mean <- get_mean(data_vector, delimiter)
for (row in c(1: rows_count)) {
middle_value <- as.numeric((interval_data[row, 1] + interval_data[row, 2]) / 2)
dispersion <- dispersion + ((middle_value - mean) ^ 2)
}
dispersion <- dispersion / length(data_vector)
return(sqrt(dispersion))
}
# Побудова графіків залежностей знайдених величин від розмірів вибірки
# Очікується вибірка розміром більшим за 100
size <- length(data) - 99
matrix_mean <- matrix(ncol = 2, nrow = size,
dimnames = list(NULL, c('size', 'value')))
matrix_deviation <- matrix(ncol = 2, nrow = size,
dimnames = list(NULL, c('size', 'value')))
for (i in c(100:length(data))) {
size_of_data <- i;
matrix_mean[i - 99, 1] = i;
matrix_mean[i - 99, 2] = get_mean(data[1:size_of_data], 1)
matrix_deviation[i - 99, 1] = i;
matrix_deviation[i - 99, 2] = get_standard_deviation(data[1:size_of_data], 1)
}
plot(matrix_mean[,1], matrix_mean[,2], type = "l")
plot(matrix_deviation[,1], matrix_deviation[,2], type = "l")
# import package:
library("fitdistrplus")
data <- scan('C:\\Users\\lemes\\Desktop\\STUDY\\MS\\2\\data.txt', vector('integer'))
# x - data for 0x axis
# y - data for 0y axis
# 1.1:
fitdist(data, "norm", "mme")
# 1.2:
fitdist(data, "norm", "mle")
y <- list() # initializing variables
j <- 0
x <- list()
for (i in 20:length(data)) { # traversing range 20..(length of data)
if (i %% 20) {
next
} # skipping each 19 elements
y[j] <- sd(data[0:i]) # calculating sd for a given range
x[j] <- i # writing range size
j <- j+1
}
plot(x, y, ylim=c(0, 15), type="l")
# import package:
library("fitdistrplus")
data <- scan('C:\\Users\\lemes\\Desktop\\STUDY\\MS\\2\\data.txt', vector('integer'))
# x - data for 0x axis
# y - data for 0y axis
# 1.1:
fitdist(data, "norm", "mme")
# 1.2:
fitdist(data, "norm", "mle")
y <- list() # initializing variables
j <- 0
x <- list()
for (i in 20:length(data)) { # traversing range 20..(length of data)
if (i %% 20) {
next
} # skipping each 19 elements
y[j] <- sd(data[0:i]) # calculating sd for a given range
x[j] <- i # writing range size
j <- j+1
}
plot(x, y, ylim=c(0, 15), type="l")
#записуемо данні у файл
inputData <- read.table('data.txt', col.names = c('Value'))
inputData
#робимо вектор з вхідної таблиці inpudData
inputVector <-as.vector(t(inputData))
inputVector
#знаходимо вибіркове середнє
Avg = mean(inputVector)
#вираховуємо середньоквадратичне відхилення
Ser_Vidh = sd(inputVector)
Ser_Vidh
#вираховуємо дисперсію
Despersion <- Ser_Vidh^2
Despersion
#виправлене середньоквадратичне відхилення
Correct_SV = sqrt(length(inputVector) * Despersion/(length(inputVector) - 1))
Correct_SV
#з таблиці 1 знаходимо значення t
t <- 1.97
#знаходимо межі інтервальних оцінок для математичного сподівання
matSpod_nyuz = Avg - (t*Correct_SV/sqrt(length(inputVector)))
matSpod_verh = Avg + (t*Correct_SV/sqrt(length(inputVector)))
matSpod_nyuz
matSpod_verh
#з таблиці 2 знаходимо значення q
q <- 0.099
#знаходимо межі інтервальних оцінок для середньоквадратичного відхилення
serKv_nyuz = Correct_SV*(1-q)
serKv_verh = Correct_SV*(1+q)
serKv_nyuz
serKv_verh
#знаходимо межі інтервальних оцінок при різних розмірах вибірки та при різних Р(дов)
#===========================================================================
#записуемо данні у файл
inputData1 <- read.table('data1.txt', col.names = c('Value'))
inputData1
#робимо вектор з вхідної таблиці inpudData
inputVector1 <-as.vector(t(inputData1))
inputVector1
#знаходимо вибіркове середнє
Avg1 = mean(inputVector1)
#вираховуємо середньоквадратичне відхилення
Ser_Vidh1 = sd(inputVector1)
Ser_Vidh1
#вираховуємо дисперсію
Despersion1 <- Ser_Vidh1^2
Despersion1
#виправлене середньоквадратичне відхилення
Correct_SV1 = sqrt(length(inputVector1) * Despersion1/(length(inputVector1) - 1))
Correct_SV1
#з таблиці 1 знаходимо значення t
t1 <- 1.98
#знаходимо межі інтервальних оцінок для математичного сподівання
matSpod_nyuz1 = Avg1 - (t1*Correct_SV1/sqrt(length(inputVector1)))
matSpod_verh1 = Avg1 + (t*Correct_SV1/sqrt(length(inputVector1)))
matSpod_nyuz1
matSpod_verh1
#з таблиці 2 знаходимо значення q
q1 <- 0.1
#знаходимо межі інтервальних оцінок для середньоквадратичного відхилення
serKv_nyuz1 = Correct_SV1*(1-q1)
serKv_verh1 = Correct_SV1*(1+q1)
serKv_nyuz1
serKv_verh1
#==============================================================
#записуемо данні у файл
inputData2 <- read.table('data2.txt', col.names = c('Value'))
inputData2
#робимо вектор з вхідної таблиці inpudData
inputVector2 <-as.vector(t(inputData2))
inputVector2
#знаходимо вибіркове середнє
Avg2 = mean(inputVector2)
#вираховуємо середньоквадратичне відхилення
Ser_Vidh2 = sd(inputVector2)
Ser_Vidh2
#вираховуємо дисперсію
Despersion2 <- Ser_Vidh2^2
Despersion2
#виправлене середньоквадратичне відхилення
Correct_SV2 = sqrt(length(inputVector2) * Despersion2/(length(inputVector2) - 1))
Correct_SV2
#з таблиці 1 знаходимо значення t
t2 <- 1.984
#знаходимо межі інтервальних оцінок для математичного сподівання
matSpod_nyuz2 = Avg2 - (t*Correct_SV2/sqrt(length(inputVector2)))
matSpod_verh2 = Avg2 + (t*Correct_SV2/sqrt(length(inputVector2)))
matSpod_nyuz2
matSpod_verh2
#з таблиці 2 знаходимо значення q
q2 <- 0.143
#знаходимо межі інтервальних оцінок для середньоквадратичного відхилення
serKv_nyuz2 = Correct_SV2*(1-q)
serKv_verh2 = Correct_SV2*(1+q)
serKv_nyuz2
serKv_verh2
#===============================================
#записуемо данні у файл
inputData3 <- read.table('data3.txt', col.names = c('Value'))
inputData3
#робимо вектор з вхідної таблиці inpudData
inputVector3 <-as.vector(t(inputData3))
inputVector3
#знаходимо вибіркове середнє
Avg3 = mean(inputVector3)
#вираховуємо середньоквадратичне відхилення
Ser_Vidh3 = sd(inputVector3)
Ser_Vidh3
#вираховуємо дисперсію
Despersion3 <- Ser_Vidh3^2
Despersion3
#виправлене середньоквадратичне відхилення
Correct_SV3 = sqrt(length(inputVector3) * Despersion3/(length(inputVector3) - 1))
Correct_SV3
#з таблиці 1 знаходимо значення t
t3 <- 1.96
#знаходимо межі інтервальних оцінок для математичного сподівання
matSpod_nyuz3 = Avg3 - (t*Correct_SV3/sqrt(length(inputVector3)))
matSpod_verh3 = Avg3 + (t*Correct_SV3/sqrt(length(inputVector3)))
matSpod_nyuz3
matSpod_verh3
#з таблиці 2 знаходимо значення q
q3 <- 0.12
#знаходимо межі інтервальних оцінок для середньоквадратичного відхилення
serKv_nyuz3 = Correct_SV3*(1-q)
serKv_verh3 = Correct_SV3*(1+q)
serKv_nyuz3
serKv_verh3
setwd("C:\\Users\\lemes\\Desktop\\STUDY\\MS\\3")
#записуемо данні у файл
inputData <- read.table('data.txt', col.names = c('Value'))
inputData
#робимо вектор з вхідної таблиці inpudData
inputVector <-as.vector(t(inputData))
inputVector
#знаходимо вибіркове середнє
Avg = mean(inputVector)
#вираховуємо середньоквадратичне відхилення
Ser_Vidh = sd(inputVector)
Ser_Vidh
#вираховуємо дисперсію
Despersion <- Ser_Vidh^2
Despersion
#виправлене середньоквадратичне відхилення
Correct_SV = sqrt(length(inputVector) * Despersion/(length(inputVector) - 1))
Correct_SV
#з таблиці 1 знаходимо значення t
t <- 1.97
#знаходимо межі інтервальних оцінок для математичного сподівання
matSpod_nyuz = Avg - (t*Correct_SV/sqrt(length(inputVector)))
matSpod_verh = Avg + (t*Correct_SV/sqrt(length(inputVector)))
matSpod_nyuz
matSpod_verh
#з таблиці 2 знаходимо значення q
q <- 0.099
#знаходимо межі інтервальних оцінок для середньоквадратичного відхилення
serKv_nyuz = Correct_SV*(1-q)
serKv_verh = Correct_SV*(1+q)
serKv_nyuz
serKv_verh
#знаходимо межі інтервальних оцінок при різних розмірах вибірки та при різних Р(дов)
#===========================================================================
#записуемо данні у файл
inputData1 <- read.table('data1.txt', col.names = c('Value'))
inputData1
#робимо вектор з вхідної таблиці inpudData
inputVector1 <-as.vector(t(inputData1))
inputVector1
#знаходимо вибіркове середнє
Avg1 = mean(inputVector1)
#вираховуємо середньоквадратичне відхилення
Ser_Vidh1 = sd(inputVector1)
Ser_Vidh1
#вираховуємо дисперсію
Despersion1 <- Ser_Vidh1^2
Despersion1
#виправлене середньоквадратичне відхилення
Correct_SV1 = sqrt(length(inputVector1) * Despersion1/(length(inputVector1) - 1))
Correct_SV1
#з таблиці 1 знаходимо значення t
t1 <- 1.98
#знаходимо межі інтервальних оцінок для математичного сподівання
matSpod_nyuz1 = Avg1 - (t1*Correct_SV1/sqrt(length(inputVector1)))
matSpod_verh1 = Avg1 + (t*Correct_SV1/sqrt(length(inputVector1)))
matSpod_nyuz1
matSpod_verh1
#з таблиці 2 знаходимо значення q
q1 <- 0.1
#знаходимо межі інтервальних оцінок для середньоквадратичного відхилення
serKv_nyuz1 = Correct_SV1*(1-q1)
serKv_verh1 = Correct_SV1*(1+q1)
serKv_nyuz1
serKv_verh1
#==============================================================
#записуемо данні у файл
inputData2 <- read.table('data2.txt', col.names = c('Value'))
inputData2
#робимо вектор з вхідної таблиці inpudData
inputVector2 <-as.vector(t(inputData2))
inputVector2
#знаходимо вибіркове середнє
Avg2 = mean(inputVector2)
#вираховуємо середньоквадратичне відхилення
Ser_Vidh2 = sd(inputVector2)
Ser_Vidh2
#вираховуємо дисперсію
Despersion2 <- Ser_Vidh2^2
Despersion2
#виправлене середньоквадратичне відхилення
Correct_SV2 = sqrt(length(inputVector2) * Despersion2/(length(inputVector2) - 1))
Correct_SV2
#з таблиці 1 знаходимо значення t
t2 <- 1.984
#знаходимо межі інтервальних оцінок для математичного сподівання
matSpod_nyuz2 = Avg2 - (t*Correct_SV2/sqrt(length(inputVector2)))
matSpod_verh2 = Avg2 + (t*Correct_SV2/sqrt(length(inputVector2)))
matSpod_nyuz2
matSpod_verh2
#з таблиці 2 знаходимо значення q
q2 <- 0.143
#знаходимо межі інтервальних оцінок для середньоквадратичного відхилення
serKv_nyuz2 = Correct_SV2*(1-q)
serKv_verh2 = Correct_SV2*(1+q)
serKv_nyuz2
serKv_verh2
#===============================================
#записуемо данні у файл
inputData3 <- read.table('data3.txt', col.names = c('Value'))
inputData3
#робимо вектор з вхідної таблиці inpudData
inputVector3 <-as.vector(t(inputData3))
inputVector3
#знаходимо вибіркове середнє
Avg3 = mean(inputVector3)
#вираховуємо середньоквадратичне відхилення
Ser_Vidh3 = sd(inputVector3)
Ser_Vidh3
#вираховуємо дисперсію
Despersion3 <- Ser_Vidh3^2
Despersion3
#виправлене середньоквадратичне відхилення
Correct_SV3 = sqrt(length(inputVector3) * Despersion3/(length(inputVector3) - 1))
Correct_SV3
#з таблиці 1 знаходимо значення t
t3 <- 1.96
#знаходимо межі інтервальних оцінок для математичного сподівання
matSpod_nyuz3 = Avg3 - (t*Correct_SV3/sqrt(length(inputVector3)))
matSpod_verh3 = Avg3 + (t*Correct_SV3/sqrt(length(inputVector3)))
matSpod_nyuz3
matSpod_verh3
#з таблиці 2 знаходимо значення q
q3 <- 0.12
#знаходимо межі інтервальних оцінок для середньоквадратичного відхилення
serKv_nyuz3 = Correct_SV3*(1-q)
serKv_verh3 = Correct_SV3*(1+q)
serKv_nyuz3
serKv_verh3
# p(дов) = 0.95
#записуемо данні у файл
inputData <- read.table('data.txt', col.names = c('Value'))
inputData
#робимо вектор з вхідної таблиці inpudData
inputVector <-as.vector(t(inputData))
inputVector
# p(дов) = 0.95
#записуемо данні у файл
inputData <- read.table('data.txt', col.names = c('Value'))
inputData
#робимо вектор з вхідної таблиці inpudData
inputVector <-as.vector(t(inputData))
inputVector
#записуемо данні у файл
inputData <- read.table('data.txt', col.names = c('Value'))
inputData
#робимо вектор з вхідної таблиці inpudData
inputVector <-as.vector(t(inputData))
inputVector
# об'єм вибірки
n <- length(inputVector)
n
#p(дов)
p <- 0.95
p
#дисперсія
Despertion <- var(inputVector)
Despertion
#математичне сподівання
matSp <- mean(inputVector)
matSp
#сер. кв. відхилення
serKv <- sqrt(findsigma(inputVector))
serKv
#виправлена дисперсія
corDes <- (n/(n - 1)) * Despertion
corDes
#виправлене сер. кв. відхилення
corSerKv <- sqrt(corDes)
corSerKv
#pnorm() , qnorm() - вбудовані функції
z <- qnorm(0.5+p/2)
error <- z * serKv / sqrt(n)
#Обрахуємо інтервали
matSp + c(-error, error)
k <- corSerKv * sqrt(n - 1)
#Нижня границя
x1 <- qchisq((1 + p) / 2, n - 1)
#Верхня границя
x2 <- qchisq((1 - p) / 2, n - 1)
k / c(sqrt(x1), sqrt(x2))
і у файл
inputData <- read.table('data.txt', col.names = c('Value'))
inputData
#робимо вектор з вхідної таблиці inpudData
inputVector <-as.vector(t(inputData))
inputVector
# об'єм вибірки
n <- length(inputVector)
n
#p(дов)
p <- 0.95
p
#дисперсія
Despertion <- var(inputVector)
Despertion
#математичне сподівання
matSp <- mean(inputVector)
matSp
#сер. кв. відхилення
serKv <- sqrt(findsigma(inputVector))
serKv
#виправлена дисперсія
corDes <- (n/(n - 1)) * Despertion
corDes
#виправлене сер. кв. відхилення
corSerKv <- sqrt(corDes)
corSerKv
#pnorm() , qnorm() - вбудовані функції
z <- qnorm(0.5+p/2)
error <- z * serKv / sqrt(n)
#Обрахуємо інтервали
matSp + c(-error, error)
k <- corSerKv * sqrt(n - 1)
#Нижня границя
x1 <- qchisq((1 + p) / 2, n - 1)
#Верхня границя
x2 <- qchisq((1 - p) / 2, n - 1)
k / c(sqrt(x1), sqrt(x2))
finda <- function(x)
{
ylist <- list()
a <- 0
n <- length(x)
for (i in 1:n)
{
a <- a + x[i]
}
a <- a/n
return(a)
}
findsigma <- function(x)
{
sigma <- 0
n <- length(x)
for (i in 1:n)
{
sigma <- sigma + (x[i]-mean(x))^2
}
sigma <- sigma/n
return(sigma)
}
#записуемо данні у файл
inputData <- read.table('data.txt', col.names = c('Value'))
inputData
#робимо вектор з вхідної таблиці inpudData
inputVector <-as.vector(t(inputData))
inputVector
# об'єм вибірки
n <- length(inputVector)
n
#p(дов)
p <- 0.95
p
#дисперсія
Despertion <- var(inputVector)
Despertion
#математичне сподівання
matSp <- mean(inputVector)
matSp
#сер. кв. відхилення
serKv <- sqrt(findsigma(inputVector))
serKv
#виправлена дисперсія
corDes <- (n/(n - 1)) * Despertion
corDes
#виправлене сер. кв. відхилення
corSerKv <- sqrt(corDes)
corSerKv
#pnorm() , qnorm() - вбудовані функції
z <- qnorm(0.5+p/2)
error <- z * serKv / sqrt(n)
#Обрахуємо інтервали
matSp + c(-error, error)
k <- corSerKv * sqrt(n - 1)
#Нижня границя
x1 <- qchisq((1 + p) / 2, n - 1)
#Верхня границя
x2 <- qchisq((1 - p) / 2, n - 1)
k / c(sqrt(x1), sqrt(x2))
